import { electronAPI as electrontToolkitAPI } from "@electron-toolkit/preload";
import type {
	BroadcastEventData,
	ShellWindowFullscreenChange,
	ShortcutActionEvent,
	ShortcutKeyPressEvent,
	ShortcutSyncEvent,
	Theme,
} from "@shared/types";
import { contextBridge, ipcRenderer } from "electron";
import { parse } from "superjson";
import { SHELL_WINDOW_FULLSCREEN_CHANGED } from "../main/constants";
import { autoGeneratedServices } from "../main/generated/preload-services";
import { getAdditionalArgv, loadDataFromTempFile } from "../main/utils";

const serverPortStr = getAdditionalArgv("server-port");
const serverPort = serverPortStr ? Number.parseInt(serverPortStr, 10) : 8089;

const app = {
	platform: process.platform,
	isDev: process.env.NODE_ENV === "development",
	serverPort,
};

const tabdata = getAdditionalArgv("tab");
const tab = tabdata ? parse(tabdata ?? "") : tabdata;
const tabsData = getAdditionalArgv("tabs");
const tabs = tabsData ? parse(tabsData ?? "") : [];

const windowId = getAdditionalArgv("window-id") ?? "";

const threadFilePath = getAdditionalArgv("thread-file") ?? "";
const messagesFilePath = getAdditionalArgv("messages-file") ?? "";

const thread = loadDataFromTempFile(threadFilePath) ?? {};
const messages = loadDataFromTempFile(messagesFilePath) ?? {};

// Use `contextBridge` APIs to expose Electron APIs to
// renderer only if context isolation is enabled, otherwise
// just add to the DOM global.
if (process.contextIsolated) {
	try {
		contextBridge.exposeInMainWorld("electron", electrontToolkitAPI);
		contextBridge.exposeInMainWorld("electronAPI", {
			theme: {
				setTheme: (theme: Theme) => ipcRenderer.send("app:theme:setTheme", theme),
				onThemeChange: (callback: (theme: Theme) => void) => {
					ipcRenderer.on("app:theme:setTheme", (_, theme) => callback(theme));
				},
				getCurrentTheme: () => ipcRenderer.invoke("app:theme:getCurrentTheme"),
			},
			shortcut: {
				onShortcutSync: (callback: (data: ShortcutSyncEvent) => void) => {
					const listener = (_: unknown, data: ShortcutSyncEvent) => callback(data);
					ipcRenderer.on("shortcut:sync", listener);
					return () => ipcRenderer.removeListener("shortcut:sync", listener);
				},
				onShortcutAction: (callback: (event: ShortcutActionEvent) => void) => {
					const listener = (_: unknown, event: ShortcutActionEvent) => callback(event);
					ipcRenderer.on("shortcut:action", listener);
					return () => ipcRenderer.removeListener("shortcut:action", listener);
				},
				sendShortcutKeyPressed: (event: ShortcutKeyPressEvent) => {
					ipcRenderer.send("shortcut:key-pressed", event);
				},
			},
			onThemeChange: (callback: (theme: string) => void) => {
				ipcRenderer.on("theme:set", (_, theme) => callback(theme));
			},
			onThreadListUpdate: (callback: () => void) => {
				ipcRenderer.on("broadcast-event", (_, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "thread-list-updated") {
						callback();
					}
				});
			},

			onScreenshotTriggered: (callback: (data: { threadId: string }) => void) => {
				const listener = (_: unknown, eventData: BroadcastEventData) => {
					if (eventData.broadcastEvent === "trigger-screenshot") {
						callback(eventData.data as { threadId: string });
					}
				};
				ipcRenderer.on("broadcast-event", listener);
				return () => ipcRenderer.removeListener("broadcast-event", listener);
			},
			onShellWindowFullscreenChange: (callback: (payload: ShellWindowFullscreenChange) => void) => {
				const listener = (_: unknown, payload: ShellWindowFullscreenChange) => callback(payload);
				ipcRenderer.on(SHELL_WINDOW_FULLSCREEN_CHANGED, listener);
				return () => ipcRenderer.removeListener(SHELL_WINDOW_FULLSCREEN_CHANGED, listener);
			},
			onPersistedStateSync: <T>(key: string, callback: (syncValue: T) => void) => {
				const listener = (_: unknown, syncValue: T) => callback(syncValue);
				ipcRenderer.on(key, listener);
				return () => ipcRenderer.removeListener(key, listener);
			},
			updater: {
				onUpdateChecking: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-checking", listener);
					return () => ipcRenderer.removeListener("updater:update-checking", listener);
				},
				onUpdateAvailable: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-available", listener);
					return () => ipcRenderer.removeListener("updater:update-available", listener);
				},
				onUpdateNotAvailable: (callback: () => void) => {
					const listener = () => callback();
					ipcRenderer.on("updater:update-not-available", listener);
					return () => ipcRenderer.removeListener("updater:update-not-available", listener);
				},
				onUpdateDownloaded: (
					callback: (data: { releaseNotes: string; releaseName: string }) => void,
				) => {
					const listener = (_: unknown, data: { releaseNotes: string; releaseName: string }) =>
						callback(data);
					ipcRenderer.on("updater:update-downloaded", listener);
					return () => ipcRenderer.removeListener("updater:update-downloaded", listener);
				},
				onUpdateError: (callback: (data: { message: string }) => void) => {
					const listener = (_: unknown, data: { message: string }) => callback(data);
					ipcRenderer.on("updater:update-error", listener);
					return () => ipcRenderer.removeListener("updater:update-error", listener);
				},
			},
			...autoGeneratedServices,
			onTabClearMessages: (callback: (data: { tabId: string; threadId: string }) => void) => {
				const listener = (_: unknown, data: { tabId: string; threadId: string }) => callback(data);
				ipcRenderer.on("tab:clear-messages", listener);
				return () => ipcRenderer.removeListener("tab:clear-messages", listener);
			},
			onTabGenerateTitle: (callback: (data: { tabId: string; threadId: string }) => void) => {
				const listener = (_: unknown, data: { tabId: string; threadId: string }) => callback(data);
				ipcRenderer.on("tab:generate-title", listener);
				return () => ipcRenderer.removeListener("tab:generate-title", listener);
			},
			aiApplication: {
				onAiApplicationsLoading: (callback: (loading: boolean) => void) => {
					const listener = (_: unknown, loading: boolean) => callback(loading);
					ipcRenderer.on("ai-applications:loading", listener);
					return () => ipcRenderer.removeListener("ai-applications:loading", listener);
				},
			},
		});

		// Expose shell window ID from process arguments
		contextBridge.exposeInMainWorld("windowId", windowId);
		contextBridge.exposeInMainWorld("tab", tab);
		contextBridge.exposeInMainWorld("tabs", tabs);
		contextBridge.exposeInMainWorld("app", app);
		contextBridge.exposeInMainWorld("thread", thread);
		contextBridge.exposeInMainWorld("messages", messages);
	} catch (error) {
		console.error("Preload: Error exposing services", { error });
	}
} else {
	window.app = app;
	window.electron = electrontToolkitAPI;
}
