/* eslint-disable @typescript-eslint/no-explicit-any */
import { ipcRenderer } from "electron";
import type {
	BroadcastEvent,
	StorageValue,
	StorageOptions,
	StorageMetadata,
	StorageMeta,
	StorageItem,
	InstalledPlugin,
	ProviderDefinition,
	PluginSource,
	ModelProvider,
	Model,
	LanguageCode,
	ShortcutBinding,
	ShortcutConflict,
	ShortcutSyncEvent,
	TabType,
	Tab,
	Theme,
	ImportResult,
	BackupInfo,
	McpServer,
	ThreadData,
} from "@shared/types";

/**
 * Auto-generated IPC service interfaces
 */
export interface AutoGeneratedIpcServices {
	broadcastService: {
		broadcastExcludeSource(broadcastEvent: BroadcastEvent, data: any): Promise<void>;
		broadcastToAll(broadcastEvent: BroadcastEvent, data: any): Promise<void>;
	};
	storageService: {
		setItem(key: string, value: StorageValue): Promise<void>;
		getItem(key: string): Promise<StorageValue | null>;
		hasItem(key: string): Promise<boolean>;
		removeItem(key: string, options: StorageOptions): Promise<void>;
		getKeys(base?: string): Promise<string[]>;
		clear(base?: string): Promise<void>;
		getMeta(key: string): Promise<StorageMetadata>;
		setMeta(key: string, metadata: StorageMeta): Promise<void>;
		removeMeta(key: string): Promise<void>;
		getItems(keys: string[]): Promise<StorageItem<StorageValue>[]>;
		setItems(items: StorageItem<StorageValue>[]): Promise<void>;
		watch(watchKey: string): Promise<void>;
		unwatch(watchKey: string): Promise<void>;
	};
	pluginService: {
		getInstalledPlugins(): Promise<InstalledPlugin[]>;
		getPlugin(pluginId: string): Promise<InstalledPlugin | null>;
		getEnabledPlugins(): Promise<InstalledPlugin[]>;
		getProviderPlugins(): Promise<ProviderDefinition[]>;
		enablePlugin(pluginId: string): Promise<void>;
		disablePlugin(pluginId: string): Promise<void>;
		installPlugin(source: PluginSource): Promise<InstalledPlugin>;
		uninstallPlugin(pluginId: string): Promise<void>;
		checkForUpdates(pluginId: string): Promise<{
			hasUpdate: boolean;
			currentVersion: string;
			latestVersion?: string;
			downloadUrl?: string;
		}>;
		updatePlugin(pluginId: string): Promise<void>;
		reloadPlugin(pluginId: string): Promise<void>;
		selectPluginFolder(): Promise<string | null>;
		getPluginConfig(pluginId: string): Promise<Record<string, unknown>>;
		setPluginConfig(pluginId: string, config: Record<string, unknown>): Promise<void>;
		getPluginConfigValue(pluginId: string, key: string): Promise<unknown>;
		setPluginConfigValue(pluginId: string, key: string, value: unknown): Promise<void>;
		fetchModelsFromProvider(provider: ModelProvider): Promise<Model[]>;
		executeBeforeSendMessageHook(context: {
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}): Promise<{
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}>;
		executeAfterSendMessageHook(
			context: {
				messages: unknown[];
				userMessage: unknown;
				model: Model;
				provider: ModelProvider;
				parameters: Record<string, unknown>;
				options: Record<string, unknown>;
			},
			response: {
				message: unknown;
				usage?: {
					promptTokens: number;
					completionTokens: number;
					totalTokens: number;
				};
				model: string;
				finishReason: string;
				metadata?: Record<string, unknown>;
			},
		): Promise<void>;
		executeErrorHook(
			errorData: { message: string; stack?: string; name?: string },
			context: {
				source: string;
				provider?: ModelProvider;
				model?: Model;
				metadata?: Record<string, unknown>;
			},
		): Promise<{
			handled: boolean;
			retry?: boolean;
			retryDelay?: number;
			message?: string;
		}>;
	};
	generalSettingsService: {
		handleLanguageChanged(language: LanguageCode): Promise<void>;
	};
	windowService: {
		handleOpenSettingsWindow(route?: string): Promise<void>;
		focusWindow(windowId: string, tabId?: string): Promise<void>;
		handleSplitShellWindow(triggerTabId: string): Promise<string | null>;
		handleMoveTabIntoExistingWindow(triggerTabId: string, windowId: string): Promise<void>;
	};
	shortcutService: {
		init(shortcuts: ShortcutBinding[]): Promise<void>;
		updateShortcuts(shortcuts: ShortcutBinding[]): Promise<void>;
		getConflicts(): Promise<ShortcutConflict[]>;
		getSyncInfo(): Promise<ShortcutSyncEvent>;
	};
	tabService: {
		handleNewTabWithThread(
			threadId: string,
			title: string,
			type: TabType,
			active: boolean,
		): Promise<string | null>;
		handleNewTab(
			title: string,
			type: TabType,
			active: boolean,
			href?: string,
		): Promise<string | null>;
		handleActivateTab(tabId: string): Promise<void>;
		getActiveTab(): Promise<Tab | null>;
		handleTabClose(tabId: string, newActiveTabId: string | null): Promise<void>;
		handleTabCloseOthers(tabId: string, tabIdsToClose: string[]): Promise<void>;
		handleTabCloseOffside(
			tabId: string,
			tabIdsToClose: string[],
			_remainingTabIds: string[],
			shouldSwitchActive: boolean,
		): Promise<void>;
		handleTabCloseAll(): Promise<void>;
		handleShellViewLevel(up: boolean): Promise<void>;
		replaceTabContent(tabId: string, newThreadId: string): Promise<boolean>;
		handleClearTabMessages(tabId: string, threadId: string): Promise<boolean>;
		handleGenerateTabTitle(tabId: string, threadId: string): Promise<boolean>;
	};
	aiApplicationService: {
		getAiApplicationUrl(applicationId: number): Promise<{
			isOk: boolean;
			url: string;
		}>;
		handle302AIProviderChange(updatedApiKey: string): Promise<void>;
		handleAiApplicationReload(tabId: string): Promise<void>;
	};
	appService: {
		setTheme(theme: Theme): Promise<void>;
		restartApp(): Promise<void>;
		resetAllData(): Promise<void>;
	};
	dataService: {
		importLegacyJson(): Promise<ImportResult>;
		exportStorage(): Promise<string | null>;
		importStorage(): Promise<ImportResult>;
		listBackups(): Promise<BackupInfo[]>;
		restoreFromBackup(backupPath: string): Promise<ImportResult>;
		deleteBackup(backupPath: string): Promise<boolean>;
		openBackupDirectory(): Promise<void>;
		checkOldVersionData(): Promise<boolean>;
	};
	externalLinkService: {
		openExternalLink(url: string): Promise<{
			isOk: boolean;
			error?: string;
		}>;
	};
	mcpService: {
		getToolsFromServer(server: McpServer): Promise<{
			isOk: boolean;
			tools?: Array<{
				name: string;
				description?: string;
				inputSchema?: Record<string, unknown>;
			}>;
			error?: string;
		}>;
		closeServer(serverId: string): Promise<{ isOk: boolean; error?: string }>;
	};
	threadService: {
		addThread(threadId: string): Promise<boolean>;
		getThreads(): Promise<ThreadData[] | null>;
		getThread(threadId: string): Promise<ThreadData | null>;
		deleteThread(threadId: string): Promise<boolean>;
		renameThread(threadId: string, newName: string): Promise<boolean>;
	};
	updaterService: {
		checkForUpdatesManually(): Promise<void>;
		quitAndInstall(): Promise<void>;
		isUpdateDownloaded(): Promise<boolean>;
		setAutoUpdate(enabled: boolean): Promise<void>;
	};
}

/**
 * Auto-generated service implementations
 */
export const autoGeneratedServices: AutoGeneratedIpcServices = {
	broadcastService: {
		broadcastExcludeSource: (broadcastEvent: BroadcastEvent, data: any) =>
			ipcRenderer.invoke("broadcastService:broadcastExcludeSource", broadcastEvent, data),
		broadcastToAll: (broadcastEvent: BroadcastEvent, data: any) =>
			ipcRenderer.invoke("broadcastService:broadcastToAll", broadcastEvent, data),
	},
	storageService: {
		setItem: (key: string, value: StorageValue) =>
			ipcRenderer.invoke("storageService:setItem", key, value),
		getItem: (key: string) => ipcRenderer.invoke("storageService:getItem", key),
		hasItem: (key: string) => ipcRenderer.invoke("storageService:hasItem", key),
		removeItem: (key: string, options: StorageOptions) =>
			ipcRenderer.invoke("storageService:removeItem", key, options),
		getKeys: (base?: string) => ipcRenderer.invoke("storageService:getKeys", base),
		clear: (base?: string) => ipcRenderer.invoke("storageService:clear", base),
		getMeta: (key: string) => ipcRenderer.invoke("storageService:getMeta", key),
		setMeta: (key: string, metadata: StorageMeta) =>
			ipcRenderer.invoke("storageService:setMeta", key, metadata),
		removeMeta: (key: string) => ipcRenderer.invoke("storageService:removeMeta", key),
		getItems: (keys: string[]) => ipcRenderer.invoke("storageService:getItems", keys),
		setItems: (items: StorageItem<StorageValue>[]) =>
			ipcRenderer.invoke("storageService:setItems", items),
		watch: (watchKey: string) => ipcRenderer.invoke("storageService:watch", watchKey),
		unwatch: (watchKey: string) => ipcRenderer.invoke("storageService:unwatch", watchKey),
	},
	pluginService: {
		getInstalledPlugins: () => ipcRenderer.invoke("pluginService:getInstalledPlugins"),
		getPlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:getPlugin", pluginId),
		getEnabledPlugins: () => ipcRenderer.invoke("pluginService:getEnabledPlugins"),
		getProviderPlugins: () => ipcRenderer.invoke("pluginService:getProviderPlugins"),
		enablePlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:enablePlugin", pluginId),
		disablePlugin: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:disablePlugin", pluginId),
		installPlugin: (source: PluginSource) =>
			ipcRenderer.invoke("pluginService:installPlugin", source),
		uninstallPlugin: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:uninstallPlugin", pluginId),
		checkForUpdates: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:checkForUpdates", pluginId),
		updatePlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:updatePlugin", pluginId),
		reloadPlugin: (pluginId: string) => ipcRenderer.invoke("pluginService:reloadPlugin", pluginId),
		selectPluginFolder: () => ipcRenderer.invoke("pluginService:selectPluginFolder"),
		getPluginConfig: (pluginId: string) =>
			ipcRenderer.invoke("pluginService:getPluginConfig", pluginId),
		setPluginConfig: (pluginId: string, config: Record<string, unknown>) =>
			ipcRenderer.invoke("pluginService:setPluginConfig", pluginId, config),
		getPluginConfigValue: (pluginId: string, key: string) =>
			ipcRenderer.invoke("pluginService:getPluginConfigValue", pluginId, key),
		setPluginConfigValue: (pluginId: string, key: string, value: unknown) =>
			ipcRenderer.invoke("pluginService:setPluginConfigValue", pluginId, key, value),
		fetchModelsFromProvider: (provider: ModelProvider) =>
			ipcRenderer.invoke("pluginService:fetchModelsFromProvider", provider),
		executeBeforeSendMessageHook: (context: {
			messages: unknown[];
			userMessage: unknown;
			model: Model;
			provider: ModelProvider;
			parameters: Record<string, unknown>;
			options: Record<string, unknown>;
		}) => ipcRenderer.invoke("pluginService:executeBeforeSendMessageHook", context),
		executeAfterSendMessageHook: (
			context: {
				messages: unknown[];
				userMessage: unknown;
				model: Model;
				provider: ModelProvider;
				parameters: Record<string, unknown>;
				options: Record<string, unknown>;
			},
			response: {
				message: unknown;
				usage?: {
					promptTokens: number;
					completionTokens: number;
					totalTokens: number;
				};
				model: string;
				finishReason: string;
				metadata?: Record<string, unknown>;
			},
		) => ipcRenderer.invoke("pluginService:executeAfterSendMessageHook", context, response),
		executeErrorHook: (
			errorData: { message: string; stack?: string; name?: string },
			context: {
				source: string;
				provider?: ModelProvider;
				model?: Model;
				metadata?: Record<string, unknown>;
			},
		) => ipcRenderer.invoke("pluginService:executeErrorHook", errorData, context),
	},
	generalSettingsService: {
		handleLanguageChanged: (language: LanguageCode) =>
			ipcRenderer.invoke("generalSettingsService:handleLanguageChanged", language),
	},
	windowService: {
		handleOpenSettingsWindow: (route?: string) =>
			ipcRenderer.invoke("windowService:handleOpenSettingsWindow", route),
		focusWindow: (windowId: string, tabId?: string) =>
			ipcRenderer.invoke("windowService:focusWindow", windowId, tabId),
		handleSplitShellWindow: (triggerTabId: string) =>
			ipcRenderer.invoke("windowService:handleSplitShellWindow", triggerTabId),
		handleMoveTabIntoExistingWindow: (triggerTabId: string, windowId: string) =>
			ipcRenderer.invoke("windowService:handleMoveTabIntoExistingWindow", triggerTabId, windowId),
	},
	shortcutService: {
		init: (shortcuts: ShortcutBinding[]) => ipcRenderer.invoke("shortcutService:init", shortcuts),
		updateShortcuts: (shortcuts: ShortcutBinding[]) =>
			ipcRenderer.invoke("shortcutService:updateShortcuts", shortcuts),
		getConflicts: () => ipcRenderer.invoke("shortcutService:getConflicts"),
		getSyncInfo: () => ipcRenderer.invoke("shortcutService:getSyncInfo"),
	},
	tabService: {
		handleNewTabWithThread: (threadId: string, title: string, type: TabType, active: boolean) =>
			ipcRenderer.invoke("tabService:handleNewTabWithThread", threadId, title, type, active),
		handleNewTab: (title: string, type: TabType, active: boolean, href?: string) =>
			ipcRenderer.invoke("tabService:handleNewTab", title, type, active, href),
		handleActivateTab: (tabId: string) => ipcRenderer.invoke("tabService:handleActivateTab", tabId),
		getActiveTab: () => ipcRenderer.invoke("tabService:getActiveTab"),
		handleTabClose: (tabId: string, newActiveTabId: string | null) =>
			ipcRenderer.invoke("tabService:handleTabClose", tabId, newActiveTabId),
		handleTabCloseOthers: (tabId: string, tabIdsToClose: string[]) =>
			ipcRenderer.invoke("tabService:handleTabCloseOthers", tabId, tabIdsToClose),
		handleTabCloseOffside: (
			tabId: string,
			tabIdsToClose: string[],
			_remainingTabIds: string[],
			shouldSwitchActive: boolean,
		) =>
			ipcRenderer.invoke(
				"tabService:handleTabCloseOffside",
				tabId,
				tabIdsToClose,
				_remainingTabIds,
				shouldSwitchActive,
			),
		handleTabCloseAll: () => ipcRenderer.invoke("tabService:handleTabCloseAll"),
		handleShellViewLevel: (up: boolean) =>
			ipcRenderer.invoke("tabService:handleShellViewLevel", up),
		replaceTabContent: (tabId: string, newThreadId: string) =>
			ipcRenderer.invoke("tabService:replaceTabContent", tabId, newThreadId),
		handleClearTabMessages: (tabId: string, threadId: string) =>
			ipcRenderer.invoke("tabService:handleClearTabMessages", tabId, threadId),
		handleGenerateTabTitle: (tabId: string, threadId: string) =>
			ipcRenderer.invoke("tabService:handleGenerateTabTitle", tabId, threadId),
	},
	aiApplicationService: {
		getAiApplicationUrl: (applicationId: number) =>
			ipcRenderer.invoke("aiApplicationService:getAiApplicationUrl", applicationId),
		handle302AIProviderChange: (updatedApiKey: string) =>
			ipcRenderer.invoke("aiApplicationService:handle302AIProviderChange", updatedApiKey),
		handleAiApplicationReload: (tabId: string) =>
			ipcRenderer.invoke("aiApplicationService:handleAiApplicationReload", tabId),
	},
	appService: {
		setTheme: (theme: Theme) => ipcRenderer.invoke("appService:setTheme", theme),
		restartApp: () => ipcRenderer.invoke("appService:restartApp"),
		resetAllData: () => ipcRenderer.invoke("appService:resetAllData"),
	},
	dataService: {
		importLegacyJson: () => ipcRenderer.invoke("dataService:importLegacyJson"),
		exportStorage: () => ipcRenderer.invoke("dataService:exportStorage"),
		importStorage: () => ipcRenderer.invoke("dataService:importStorage"),
		listBackups: () => ipcRenderer.invoke("dataService:listBackups"),
		restoreFromBackup: (backupPath: string) =>
			ipcRenderer.invoke("dataService:restoreFromBackup", backupPath),
		deleteBackup: (backupPath: string) =>
			ipcRenderer.invoke("dataService:deleteBackup", backupPath),
		openBackupDirectory: () => ipcRenderer.invoke("dataService:openBackupDirectory"),
		checkOldVersionData: () => ipcRenderer.invoke("dataService:checkOldVersionData"),
	},
	externalLinkService: {
		openExternalLink: (url: string) =>
			ipcRenderer.invoke("externalLinkService:openExternalLink", url),
	},
	mcpService: {
		getToolsFromServer: (server: McpServer) =>
			ipcRenderer.invoke("mcpService:getToolsFromServer", server),
		closeServer: (serverId: string) => ipcRenderer.invoke("mcpService:closeServer", serverId),
	},
	threadService: {
		addThread: (threadId: string) => ipcRenderer.invoke("threadService:addThread", threadId),
		getThreads: () => ipcRenderer.invoke("threadService:getThreads"),
		getThread: (threadId: string) => ipcRenderer.invoke("threadService:getThread", threadId),
		deleteThread: (threadId: string) => ipcRenderer.invoke("threadService:deleteThread", threadId),
		renameThread: (threadId: string, newName: string) =>
			ipcRenderer.invoke("threadService:renameThread", threadId, newName),
	},
	updaterService: {
		checkForUpdatesManually: () => ipcRenderer.invoke("updaterService:checkForUpdatesManually"),
		quitAndInstall: () => ipcRenderer.invoke("updaterService:quitAndInstall"),
		isUpdateDownloaded: () => ipcRenderer.invoke("updaterService:isUpdateDownloaded"),
		setAutoUpdate: (enabled: boolean) =>
			ipcRenderer.invoke("updaterService:setAutoUpdate", enabled),
	},
};

/**
 * Export type declaration extensions
 */
export interface ElectronAPIExtension {
	broadcastService: AutoGeneratedIpcServices["broadcastService"];
	storageService: AutoGeneratedIpcServices["storageService"];
	pluginService: AutoGeneratedIpcServices["pluginService"];
	generalSettingsService: AutoGeneratedIpcServices["generalSettingsService"];
	windowService: AutoGeneratedIpcServices["windowService"];
	shortcutService: AutoGeneratedIpcServices["shortcutService"];
	tabService: AutoGeneratedIpcServices["tabService"];
	aiApplicationService: AutoGeneratedIpcServices["aiApplicationService"];
	appService: AutoGeneratedIpcServices["appService"];
	dataService: AutoGeneratedIpcServices["dataService"];
	externalLinkService: AutoGeneratedIpcServices["externalLinkService"];
	mcpService: AutoGeneratedIpcServices["mcpService"];
	threadService: AutoGeneratedIpcServices["threadService"];
	updaterService: AutoGeneratedIpcServices["updaterService"];
}
